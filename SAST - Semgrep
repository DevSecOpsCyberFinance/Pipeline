pipeline {
  agent any

  parameters {
    booleanParam(name: 'FAIL_ON_FINDINGS', defaultValue: false, description: 'Si true -> el job falla si hay vulnerabilidades. Si false -> siempre SUCCESS.')
  }

  environment {
    SRC = '/projects/Cyberfinance-Bank-main'
    IMG = 'returntocorp/semgrep:latest'
  }

  stages {
    stage('Prepare workspace (rsync without owner/perms)') {
      steps {
        sh '''
          set -e
          rm -rf "$WORKSPACE"/* || true
          rsync -r --delete --exclude='.git' --exclude='node_modules' \
            --no-owner --no-group --no-perms \
            --chmod=Du=rwx,Dg=rx,Do=rx,Fu=rw,Fg=r,Fo=r \
            "${SRC}/" "$WORKSPACE/" 2>/dev/null || {
              echo "rsync falló, fallback con tar..."
              (cd "${SRC}" && tar -c .) | tar -x -C "$WORKSPACE"
              find "$WORKSPACE" -type d -print0 | xargs -0 chmod 755 || true
              find "$WORKSPACE" -type f -print0 | xargs -0 chmod 644 || true
            }
          echo "Permisos y contenido del workspace:"
          ls -ld "$WORKSPACE"
          ls -l "$WORKSPACE" | head -n 50
        '''
      }
    }

    stage('Semgrep - Backend') {
      steps {
        sh '''
          set -e
          docker run --rm -u "$(id -u):$(id -g)" -e HOME=/tmp -v "$WORKSPACE":/src ${IMG} \
            semgrep scan --config=auto --json --output /src/semgrep-backend.json /src/Backend || true
        '''
      }
      post { always { archiveArtifacts artifacts: 'semgrep-backend.json', allowEmptyArchive: true, fingerprint: true } }
    }

    stage('Semgrep - Frontend') {
      steps {
        sh '''
          set -e
          docker run --rm -u "$(id -u):$(id -g)" -e HOME=/tmp -v "$WORKSPACE":/src ${IMG} \
            semgrep scan --config=auto --json --output /src/semgrep-frontend.json /src/Frontend || true
        '''
      }
      post { always { archiveArtifacts artifacts: 'semgrep-frontend.json', allowEmptyArchive: true, fingerprint: true } }
    }

    stage('Summarize & conditional exit') {
      steps {
        sh '''
          set -e

          # contar backend
          backend_count=$( [ -f semgrep-backend.json ] && \
            python3 -c "import json,sys; print(len(json.load(open('semgrep-backend.json')).get('results',[])))" 2>/dev/null || echo 0 )

          # contar frontend
          frontend_count=$( [ -f semgrep-frontend.json ] && \
            python3 -c "import json,sys; print(len(json.load(open('semgrep-frontend.json')).get('results',[])))" 2>/dev/null || echo 0 )

          # asegurar que sean enteros
          backend_count=${backend_count:-0}
          frontend_count=${frontend_count:-0}
          total=$(( backend_count + frontend_count ))

          # escribir resumen con breakdown
          cat > semgrep-report-summary.txt <<EOF
backend_findings=${backend_count}
frontend_findings=${frontend_count}
total_findings=${total}
EOF

          echo "Findings breakdown: Backend: ${backend_count} — Frontend: ${frontend_count} — Total: ${total}"

          # decidir exit según el parámetro FAIL_ON_FINDINGS
          # Jenkins inyecta el parámetro como string "true"/"false"
          if [ "${FAIL_ON_FINDINGS}" = "true" ] && [ "${total}" -gt 0 ]; then
            echo "FAIL_ON_FINDINGS=true y total>0 -> saliendo con código 1"
            exit 1
          fi

          echo "Salida exit 0 (no hay findings o FAIL_ON_FINDINGS=false)"
          exit 0
        '''
      }
      post {
        always {
          archiveArtifacts artifacts: 'semgrep-report-summary.txt', allowEmptyArchive: true, fingerprint: true
          sh 'echo "Summary: $(cat semgrep-report-summary.txt 2>/dev/null || echo no-summary)"'
        }
      }
    }
  }

  post {
    success { echo "Security pipeline: final SUCCESS." }
    failure { echo "Security pipeline: final FAILURE (revisa artefactos)." }
  }
}
